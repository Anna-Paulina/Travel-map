<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Travel Map</title>

<!-- Leaflet -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>

<!-- Routing -->
<link rel="stylesheet" href="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.css"/>

<style>
body {
  margin: 0;
  font-family: system-ui, -apple-system, BlinkMacSystemFont;
}
#map {
  height: 90vh;
}
.popup-img {
  width: 100%;
  border-radius: 8px;
  margin-top: 6px;
}
</style>

<!-- PapaParse -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>

<!-- Leaflet -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<!-- Routing -->
<script src="https://unpkg.com/leaflet-routing-machine@3.2.12/dist/leaflet-routing-machine.js"></script>
</head>

<body>
<h3 style="padding:8px">üåç Travel route</h3>
<div id="map"></div>

<script>
const map = L.map("map").setView([15, -90], 5);

L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
  attribution: "¬© OpenStreetMap"
}).addTo(map);

// =======================
// LOAD CSV FROM GITHUB
// =======================
Papa.parse("trip.csv", {
  download: true,
  header: true,
  skipEmptyLines: true,
  complete: function (results) {

    const points = [];
    const bounds = [];

    results.data.forEach(row => {
      const lat = parseFloat(row.Latitude);
      const lng = parseFloat(row.Longitude);
      const name = row.Lieu;
      const days = row["Jours sur place"];

      if (isNaN(lat) || isNaN(lng)) return;

      const placeQuery = encodeURIComponent(name);
      const imageUrl = `https://source.unsplash.com/400x300/?${placeQuery}`;

      const marker = L.marker([lat, lng]).addTo(map);
      marker.bindPopup(`
        <strong>${name}</strong><br>
        ‚è± ${days} day(s)<br>
        <img class="popup-img" src="${imageUrl}">
      `);

      const ll = L.latLng(lat, lng);
      points.push(ll);
      bounds.push(ll);
    });

    if (bounds.length) map.fitBounds(bounds);
    drawSegments(points);
  }
});

// =======================
// ROUTING SEGMENTS
// =======================
function drawSegments(points) {
  let i = 0;

  function next() {
    if (i >= points.length - 1) return;

    const from = points[i];
    const to = points[i + 1];

    L.Routing.control({
      waypoints: [from, to],
      router: L.Routing.osrmv1({
        serviceUrl: "https://router.project-osrm.org/route/v1"
      }),
      addWaypoints: false,
      draggableWaypoints: false,
      show: false,
      fitSelectedRoutes: false,
      createMarker: () => null,
      lineOptions: {
        styles: [{ color: "#1e88e5", weight: 5 }]
      }
    })
    .on("routesfound", e => {
      const leg = e.routes[0].legs[0];
      const line = e.routes[0].coordinates.map(c => [c.lat, c.lng]);

      const poly = L.polyline(line, { color: "#1e88e5", weight: 5 }).addTo(map);
      poly.on("click", ev => {
        L.popup()
          .setLatLng(ev.latlng)
          .setContent(`
            üöó <strong>Segment ${i+1}</strong><br>
            Distance: ${(leg.distance/1000).toFixed(1)} km<br>
            Duration: ${(leg.time/3600).toFixed(1)} h
          `)
          .openOn(map);
      });

      i++; setTimeout(next, 600);
    })
    .on("routingerror", () => {
      const poly = L.polyline([from, to], {
        color: "#e53935",
        dashArray: "6,6",
        weight: 4
      }).addTo(map);

      const km = from.distanceTo(to)/1000;
      poly.on("click", ev => {
        L.popup()
          .setLatLng(ev.latlng)
          .setContent(`
            ‚ö†Ô∏è No road<br>
            Distance (air): ${km.toFixed(1)} km
          `)
          .openOn(map);
      });

      i++; setTimeout(next, 600);
    });
  }

  next();
}
</script>
</body>
</html>
